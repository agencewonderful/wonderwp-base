<?php
/**
 * Created by PhpStorm.
 * User: jeremydesvaux
 * Date: 09/08/2016
 * Time: 17:16
 */

namespace WonderWp\Plugin\Recette;


use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\Entity;
use Respect\Validation\Validator;
use Symfony\Component\HttpFoundation\Request;
use WonderWp\DI\Container;
use WonderWp\Entity\AbstractEntity;
use WonderWp\Entity\EntityAttribute;
use WonderWp\Entity\EntityRelation;
use WonderWp\Forms\Fields\AbstractField;
use WonderWp\Forms\Fields\AbstractFieldGroup;
use WonderWp\Forms\Fields\BooleanField;
use WonderWp\Forms\Fields\BtnField;
use WonderWp\Forms\Fields\CategoryField;
use WonderWp\Forms\Fields\FieldGroup;
use WonderWp\Forms\Fields\HiddenField;
use WonderWp\Forms\Fields\InputField;
use WonderWp\Forms\Fields\FileField;
use WonderWp\Forms\Fields\NumericField;
use WonderWp\Forms\Fields\SelectField;
use WonderWp\Forms\Fields\TextAreaField;
use WonderWp\Forms\Form;
use WonderWp\Forms\FormGroup;
use WonderWp\Forms\FormInterface;
use WonderWp\Forms\FormValidatorInterface;
use WonderWp\Forms\ModelForm;
use WonderWp\Plugin\Forms\Fields\LocaleField;
use WonderWp\Plugin\Forms\Fields\MediaField;

/**
 * Class RecetteForm
 * @package WonderWp\Plugin\Recette
 * Class that defines the form to use when adding / editing the entity
 */
class RecetteForm extends ModelForm
{
    public function setFormInstance(FormInterface $formInstance)
    {
        $formInstance->setName('recette-form');
        return parent::setFormInstance($formInstance); // TODO: Change the autogenerated stub
    }

    public function preBuild()
    {
        //Fieldset Infos recette
        $this->_formInstance->addGroup(new FormGroup('recette', __('infosrecette.trad', WWP_RECETTE_TEXTDOMAIN)));
    }

    public function newField(EntityAttribute $attr)
    {
        $fieldName = $attr->getFieldName();
        $entity = $this->getModelInstance();
        $val = $entity->$fieldName;
        $label = __($fieldName . '.trad', $this->_textDomain);

        //Add here particular cases for your different fields
        switch ($fieldName) {
            case'media':
                $f = new MediaField($fieldName, $val, ['label' => $label]);
                break;
            case 'locale':
                $f = LocaleField::getInstance($fieldName,$val,['label' => $label]);
                break;
            case 'slug':
                $f = new HiddenField($fieldName, sanitize_title($this->_modelInstance->getTitle()));
                break;
            default:
                $f = parent::newField($attr);
                break;
        }
        return $f;
    }

    public function newRelation(EntityRelation $relationAttr)
    {
        $fieldName = $relationAttr->getFieldName();
        if (method_exists($this, '_generate' . ucfirst($fieldName) . 'Group')) {
            call_user_func(array($this, '_generate' . ucfirst($fieldName) . 'Group'));
        }
    }

    public function addField(AbstractField $f, $groupName = '')
    {
        if (empty($groupName)) {
            $groupName = 'recette';
        }
        parent::addField($f, $groupName);
    }

    private function _generateMetasGroup()
    {

        $metas = $this->_modelInstance->getMetas();
        $metaValues = array();

        if (!empty($metas)) {
            foreach ($metas as $i => $meta) {
                /** @var RecetteMeta $meta */
                $metaValues[$meta->getName()] = $meta->getVal();
            }
        }

        //Metas
        $this->_formInstance->addGroup(new FormGroup('metas', __('metasrecette.trad', WWP_RECETTE_TEXTDOMAIN), ['class' => ['closed']]));

        $metaFieldsDef = array(
            ['nbPers', InputField::class,true], //Nombre de personnes
            ['tpsPrepa', InputField::class,true], //Temps de préparation
            ['tpsCuisson', InputField::class,false], //Temps de cuisson
            ['difficulte', InputField::class,true], //Difficulté
            ['cout', InputField::class,false], //Cout
            ['published', BooleanField::class,false], //Publication
            ['astuce', TextAreaField::class,false] //Astuce
        );

        if (!empty($metaFieldsDef)) {
            foreach ($metaFieldsDef as $def) {
                $displayRules = [
                    'label' => __('meta.' . $def[0] . '.trad', WWP_RECETTE_TEXTDOMAIN),
                    'inputAttributes' => ['name' => 'metas[' . $def[0] . ']']
                ];
                $validationRules = array();
                if($def[2]){ $validationRules[] = Validator::notEmpty(); }

                $f = new $def[1]('metas_' . $def[0], (!empty($metaValues[$def[0]]) ? $metaValues[$def[0]] : null), $displayRules,$validationRules);
                $this->_formInstance->addField($f, 'metas');
            }
        }

        //Saveur
        $displayRules = [
            'label' => __('meta.metas_saveur.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'metas[metas_saveur]']
        ];
        $f = new CategoryField('metas_saveur', (!empty($metaValues['metas_saveur']) ? $metaValues['metas_saveur'] : null), $displayRules,[Validator::notEmpty()],4);
        $this->_formInstance->addField($f, 'metas');

        //Moment de conso
        $displayRules = [
            'label' => __('meta.metas_moment.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'metas[metas_moment]']
        ];
        $f = new CategoryField('metas_moment', (!empty($metaValues['metas_moment']) ? $metaValues['metas_moment'] : null), $displayRules,[Validator::notEmpty()],9);
        $this->_formInstance->addField($f, 'metas');

        //Type de plat
        $displayRules = [
            'label' => __('meta.metas_type_plat.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'metas[metas_type_plat]']
        ];
        $f = new CategoryField('metas_type_plat', (!empty($metaValues['metas_type_plat']) ? $metaValues['metas_type_plat'] : null), $displayRules,[Validator::notEmpty()],13);
        $this->_formInstance->addField($f, 'metas');

        //Auteur
        $displayRules = [
            'label' => __('meta.metas_auteur.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'metas[auteur]']
        ];
        $f = new CategoryField('metas_auteur', (!empty($metaValues['auteur']) ? $metaValues['auteur'] : null), $displayRules,[],18);
        $this->_formInstance->addField($f, 'metas');

    }

    private function _generateIngredientsGroup()
    {
        $locale = get_locale();
        $container = Container::getInstance();
        /** @var EntityManager $entityManager */
        $entityManager = $container->offsetGet('entityManager');

        //Create field group
        $this->_formInstance->addGroup(new FormGroup('ingredients', __('ingredients.trad', WWP_RECETTE_TEXTDOMAIN), ['class' => ['closed']]));

        //Get recipe ingredients
        $thisIngredients = $this->_modelInstance->getIngredients();
        $selectedIngredienIds = $thisIngredients->map(function ($entity) {
            return $entity->getId();
        })->toArray();

        //List all available ingredients;
        $ingredientRepository = $entityManager->getRepository(Ingredient::class);
        $availableIngredients = $ingredientRepository->findBy([], ['slug' => 'ASC']);

        $displayRules = [
            'label' => __('ingredients.add.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => [
                'multiple' => 'multiple',
                'class' => ['ingredientsPicker']
            ]
        ];
        $f = new SelectField('ingredients', $selectedIngredienIds, $displayRules,[Validator::notEmpty()]);
        if (!empty($availableIngredients)) {
            $ingredientOptions = array(
                '' => __('ingredients.choose.trad', WWP_RECETTE_TEXTDOMAIN)
            );
            foreach ($availableIngredients as $ingredient) {
                /** @var Ingredient $ingredient */
                /** @var IngredientTrad $tradObj */
                $tradObj = $ingredient->getTranslation($locale);
                $trad = is_object($tradObj) ? $tradObj->getTitle() : $ingredient->getSlug();
                $ingredientOptions[$ingredient->getId()] = $trad;
            }
            $f->setOptions($ingredientOptions);
        }

        $this->_formInstance->addField($f, 'ingredients');


        //Unit picker
        $displayRules = [
            'wrapAttributes'=>['class'=>['hidden']],
            'label' => __('unit.picker.trad', WWP_RECETTE_TEXTDOMAIN)
        ];
        $f = new CategoryField('unit_picker', null, $displayRules,[],22);
        $this->_formInstance->addField($f, 'ingredients');

    }

    private function _generateEtapesGroup()
    {
        //Create field group
        $this->_formInstance->removeGroup('etapes');
        $this->_formInstance->addGroup(new FormGroup('etapes', __('etapes.trad', WWP_RECETTE_TEXTDOMAIN)));

        //Get recipe etapes
        $thisEtapes = $this->_modelInstance->getEtapes();

        //One field group per etape
        if (!empty($thisEtapes)) {
            /** @var RecetteEtape $etape */
            foreach ($thisEtapes as $etape) {
                $f = $this->_generateEtapeGroup($etape);
                $this->_formInstance->addField($f, 'etapes');
            }
        }

        //Add etape btn
        $addBtn = new BtnField('add-etape', null, ['label' => 'Ajouter une étape']);
        $this->_formInstance->addField($addBtn, 'etapes');

        //One extra field for new steps
        $f = $this->_generateEtapeGroup(new RecetteEtape());
        $this->_formInstance->addField($f, 'etapes');
    }

    private function _generateEtapeGroup(RecetteEtape $etape)
    {
        $i = $etape->getId();
        if (empty($i)) {
            $i = '_newstep_';
        }

        /** @var RecetteEtape $etape */
        $displayRules = array();
        if ($i == '_newstep_') {
            $displayRules['inputAttributes']['class'] = ['nouvelle-etape', 'hidden'];
            $validationRules=[];
        } else {
            $displayRules['inputAttributes']['class'] = ['etape'];
            $displayRules['after'] = '<button class="button remove-etape">Supprimer</button>';
            $validationRules=[Validator::notEmpty()];
        }
        $displayRules['wrapAttributes'] = ['no-wrap' => true];
        $f = new FieldGroup('etapes' . $i, null, $displayRules);

        //Id
        $displayRules = [
            'inputAttributes' => [
                'name' => 'etapes[' . $i . '][id]',
                'class'=>['etape-id']
            ]
        ];
        $eId = new HiddenField('etape_' . $i . '_id', $etape->getId(), $displayRules);
        $f->addFieldToGroup($eId);

        //Title
        $displayRules = [
            'inputAttributes' => [
                'name' => 'etapes[' . $i . '][title]',
                'placeholder' => __('etape.title.trad', WWP_RECETTE_TEXTDOMAIN),
                'class' => ['etape-title']
            ]
        ];
        $eTitle = new InputField('etape_' . $i . '_title', $etape->getTitle(), $displayRules,$validationRules);
        $f->addFieldToGroup($eTitle);

        //Media
        $displayRules = [
            'label' => __('etape.media.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'etapes[' . $i . '][media]'],
            'wrapAttributes' => ['class' => ['media-wrap']]
        ];
        $eMedia = new FileField('etape_' . $i . '_media', $etape->getMedia(), $displayRules);
        $f->addFieldToGroup($eMedia);

        //Ingredients
        $etapeIngredientsWrap = new FieldGroup('EtapeIngredientsWrap' . $i,null,['label' => __('etape.ingredients.trad', WWP_RECETTE_TEXTDOMAIN)]);

        $availableIngredients = $this->_modelInstance->getIngredients();
        $thisEtapeIngredients = $etape->getEtapeIngredients();
        $selectedIngredienIds = $thisEtapeIngredients->map(function ($entity) {
            return $entity->getIngredient()->getId();
        })->toArray();

        //Liste
        $locale = get_locale();
        $list='<br /><label>'.__('etape.ingredient.list.title.trad', WWP_RECETTE_TEXTDOMAIN).'</label>
        <ul class="stepIngredients">';
        if (!empty($thisEtapeIngredients)) {
            foreach ($thisEtapeIngredients as $etapeIngredient) {
                /** @var $etapeIngredient \WonderWp\Plugin\Recette\EtapeIngredient */
                $ingredient = $etapeIngredient->getIngredient();
                if(!empty($ingredient)) {
                    try {
                        $trad = $ingredient->getTranslation($locale);
                        if (!empty($trad)) {
                            $qty = $etapeIngredient->getQty();
                            $unitCat = get_category($etapeIngredient->getUnit());
                            $unitTrad = !is_wp_error($unitCat) ? __('term_' . $unitCat->slug, WWP_RECETTE_TEXTDOMAIN) : null;

                            $list .= '<li>                        
                            <a href="#">' . ($qty > 0 ? $qty : '') . ' ' . $unitTrad . ' ' . $trad->getTitle() . '</a>
                            <input type="hidden" class="ingredient-qty" name="etapes[' . $i . '][ingredients][' . $ingredient->getId() . '][qty]" value="' . (int)$qty . '" />
                            <input type="hidden" class="ingredient-unit" data-name="' . $unitTrad . '" name="etapes[' . $i . '][ingredients][' . $ingredient->getId() . '][unit]" value="' . (int)$etapeIngredient->getUnit() . '" />
                            <input type="hidden" class="ingredient-id" data-name="' . $trad->getTitle() . '" name="etapes[' . $i . '][ingredients][' . $ingredient->getId() . '][id]" value="' . $ingredient->getId() . '" />
                            <button class="button delete-wrap">&times;</button>
                        </li>';
                        }
                    } catch (\Doctrine\ORM\EntityNotFoundException $nf) {

                    }
                }
            }
        }
        $list.='</ul>';

        //Recherche
        $displayRules = [
            'label' => __('etape.recherche.ingredients.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => [
                'name' => ' ',
                'multiple' => 'multiple',
                'class' => ['ingredientsPicker']
            ],
            'after'=>$list
        ];
        $selectedIngredienIds = $thisEtapeIngredients->map(function ($entity) {
            return $entity->getIngredient()->getId();
        })->toArray();
        $eIngredients = new SelectField('etape_' . $i . '_ingredients', $selectedIngredienIds, $displayRules,$validationRules);
        $ingredientOptions = array();
        foreach ($availableIngredients as $ingredient) {
            /** @var Ingredient $ingredient */
            $trad = $ingredient->getTranslation($locale);
            if(!empty($trad)) {
                $ingredientOptions[$ingredient->getId()] = $trad->getTitle();
            }
        }
        $eIngredients->setOptions($ingredientOptions);


        $etapeIngredientsWrap->addFieldToGroup($eIngredients);
        $f->addFieldToGroup($etapeIngredientsWrap);


        //Instructions
        $displayRules = [
            'label' => __('etape.instructions.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'etapes[' . $i . '][content]']
        ];
        $eInstructions = new TextAreaField('etape_' . $i . '_content', $etape->getContent(), $displayRules,$validationRules);
        $f->addFieldToGroup($eInstructions);

        return $f;
    }

    public function handleRequest(array $data, FormValidatorInterface $formValidator)
    {

        $postedData = $data;

        //Extract Metas
        $rawMetasData = array();
        if (isset($data['metas'])) {
            $rawMetasData = $data['metas'];
            unset($data['metas']);
        }

        //Extract Ingredients
        $rawIngredientsData = array();
        if (isset($data['ingredients'])) {
            $rawIngredientsData = $data['ingredients'];
            unset($data['ingredients']);
        }

        //Extract Etapes
        $rawEtapesData = array();
        if (isset($data['etapes'])) {
            $rawEtapesData = $data['etapes'];
            unset($data['etapes']);
        }

        $errors = parent::handleRequest($data, $formValidator);
        $this->_formInstance->fill($postedData);

        if (!empty($errors)) {
            return $errors;
        }

        $container = Container::getInstance();
        /** @var EntityManager $em */
        $this->_em = $container->offsetGet('entityManager');
        $em = $this->_em;

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;

        //Process Metas
        $metaErrors = $this->_handleMetas($rawMetasData);
        $errors = $errors + $metaErrors;

        //Process Ingredients
        $ingredientErrors = $this->_handleIngredients($rawIngredientsData, $recette);
        $errors = $errors + $ingredientErrors;

        //Process Etapes
        $etapesErrors = $this->_handleEtapes($rawEtapesData);
        $errors = $errors + $etapesErrors;

        $em->flush();

        return $errors;
    }

    private function _handleMetas(array $rawMetasData)
    {
        $errors = array();

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;
        /** @var EntityManager $em */
        $em = $this->_em;

        //Remove old metas
        $currentMetas = $recette->getMetas();
        if (!empty($currentMetas)) {
            foreach ($currentMetas as $m) {
                $recette->removeMeta($m);
                $em->remove($m);
            }
            $em->flush();
        }

        //Add new metas
        if (!empty($rawMetasData)) {
            foreach ($rawMetasData as $key => $val) {
                $meta = new RecetteMeta();
                $meta
                    ->setName($key)
                    ->setVal($val)
                    ->setRecette($recette);
                if ($recette->addMeta($meta)) {
                    $em->persist($meta);
                }
            }
        }
        return $errors;
    }

    private function _handleIngredients(array $rawIngredientsData, AbstractEntity $entity)
    {
        //\WonderWp\trace($rawIngredientsData);
        $errors = array();

        /** @var EntityManager $em */
        $em = $this->_em;
        $thisIngredients = $entity->getIngredients();

        //Remove old ingredients
        //aka those which are in my collection but not the posted ids
        $ingredientsToRemove = $thisIngredients->filter(
            function ($entry) use ($rawIngredientsData) {
                return !in_array($entry->getId(), $rawIngredientsData);
            }
        );
        if (!empty($ingredientsToRemove)) {
            foreach ($ingredientsToRemove as $i) {
                $entity->removeIngredient($i);
            }
            $em->flush();
        }

        //Add new ingredients
        if (!empty($rawIngredientsData)) {
            foreach ($rawIngredientsData as $ingredientId) {
                $ingredient = $em->find(Ingredient::class, $ingredientId);
                $entity->addIngredient($ingredient);
            }
        }

        return $errors;

    }

    private function _handleEtapes($rawEtapesData)
    {

        if (isset($rawEtapesData['_newstep_'])) {
            unset($rawEtapesData['_newstep_']);
        }

        $errors = array();

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;

        /** @var EntityManager $em */
        $em = $this->_em;

        //Remove old etapes
        //aka those which are in my collection but not the posted ids
        $etapesToRemove = $recette->getEtapes()->filter(
            function ($entry) use ($rawEtapesData) {
                return !in_array($entry->getId(), array_keys($rawEtapesData));
            }
        );

        if (!empty($etapesToRemove)) {
            foreach ($etapesToRemove as $e) {
                $recette->removeEtape($e);
            }
            $em->flush();
        }

        //Recreate etapes
        if (!empty($rawEtapesData)) {
            foreach ($rawEtapesData as $val) {
                $id = $val['id'];

                //Extract Ingredients
                $rawIngredientsData = array();
                if (isset($val['ingredients'])) {
                    $rawIngredientsData = $val['ingredients'];
                    unset($val['ingredients']);
                }

                if (strpos($val['id'],'_newstep_')===false) {
                    $etape = $em->find(RecetteEtape::class, $id);
                } else {
                    if (empty($val['title'])) {
                        continue;
                    } //pas de donnees postees pour ajouter une nouvelle etape
                    $etape = new RecetteEtape();
                    $em->persist($etape);
                    $recette->addEtape($etape);
                    $val['id'] = $recette->getId();
                }
                $etape->populate($val);

                $em->flush();
                $this->_handleEtapeIngredients($rawIngredientsData, $etape);
            }
        }
        $em->flush();

        $this->_generateEtapesGroup();

        return $errors;
    }

    private function _handleEtapeIngredients($rawEtapeIngredientsData, RecetteEtape $etape){

        /** @var EntityManager $em */
        $em = $this->_em;

        //Remove other etapeIngredients
        $eid = $etape->getId();
        if($eid>0) {
            $query = $em->createQuery('DELETE ' . EtapeIngredient::class . ' ei WHERE ei.recetteEtape = ' . $etape->getId());
            $query->execute();
        }

        $etape->setEtapeIngredients(new ArrayCollection());

        //Add ingredients
        if(!empty($rawEtapeIngredientsData)){ foreach($rawEtapeIngredientsData as $rawEtapeIngredientData){
            $etapeIngredient = new EtapeIngredient();
            $etapeIngredient->setQty($rawEtapeIngredientData['qty'])
                ->setUnit($rawEtapeIngredientData['unit']);
            $ingredient = $item = $em->find(Ingredient::class, $rawEtapeIngredientData['id']);

            $etape->addEtapeIngredient($etapeIngredient);
            $ingredient->addEtapeIngredient($etapeIngredient);
        }}

        $em->flush();
    }

}