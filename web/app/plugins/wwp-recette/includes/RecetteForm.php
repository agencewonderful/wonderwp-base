<?php
/**
 * Created by PhpStorm.
 * User: jeremydesvaux
 * Date: 09/08/2016
 * Time: 17:16
 */

namespace WonderWp\Plugin\Recette;


use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Mapping\Entity;
use Symfony\Component\HttpFoundation\Request;
use WonderWp\DI\Container;
use WonderWp\Entity\AbstractEntity;
use WonderWp\Entity\EntityAttribute;
use WonderWp\Entity\EntityRelation;
use WonderWp\Forms\Fields\AbstractField;
use WonderWp\Forms\Fields\AbstractFieldGroup;
use WonderWp\Forms\Fields\BooleanField;
use WonderWp\Forms\Fields\BtnField;
use WonderWp\Forms\Fields\FieldGroup;
use WonderWp\Forms\Fields\HiddenField;
use WonderWp\Forms\Fields\InputField;
use WonderWp\Forms\Fields\MediaField;
use WonderWp\Forms\Fields\NumericField;
use WonderWp\Forms\Fields\SelectField;
use WonderWp\Forms\Fields\TextAreaField;
use WonderWp\Forms\Form;
use WonderWp\Forms\FormGroup;
use WonderWp\Forms\FormInterface;
use WonderWp\Forms\FormValidatorInterface;
use WonderWp\Forms\ModelForm;

/**
 * Class RecetteForm
 * @package WonderWp\Plugin\Recette
 * Class that defines the form to use when adding / editing the entity
 */
class RecetteForm extends ModelForm
{
    public function setFormInstance(FormInterface $formInstance)
    {
        $formInstance->setName('recette-form');
        return parent::setFormInstance($formInstance); // TODO: Change the autogenerated stub
    }

    public function preBuild()
    {
        //Fieldset Infos recette
        $this->_formInstance->addGroup(new FormGroup('recette', __('infosrecette.trad', WWP_RECETTE_TEXTDOMAIN)));
    }

    public function newField(EntityAttribute $attr)
    {
        $fieldName = $attr->getFieldName();
        $entity = $this->getModelInstance();
        $val = $entity->$fieldName;
        $label = __($fieldName . '.trad', $this->_textDomain);

        //Add here particular cases for your different fields
        switch ($fieldName) {
            case'media':
                $f = new MediaField($fieldName, $val, ['label' => $label]);
                break;
            default:
                $f = parent::newField($attr);
                break;
        }
        return $f;
    }

    public function newRelation(EntityRelation $relationAttr)
    {
        $fieldName = $relationAttr->getFieldName();
        if (method_exists($this, '_generate' . ucfirst($fieldName) . 'Group')) {
            call_user_func(array($this, '_generate' . ucfirst($fieldName) . 'Group'));
        }
    }

    public function addField(AbstractField $f, $groupName = '')
    {
        if (empty($groupName)) {
            $groupName = 'recette';
        }
        parent::addField($f, $groupName);
    }

    private function _generateMetasGroup()
    {

        $metas = $this->_modelInstance->getMetas();
        $metaValues = array();

        if (!empty($metas)) {
            foreach ($metas as $i => $meta) {
                /** @var RecetteMeta $meta */
                $metaValues[$meta->getName()] = $meta->getVal();
            }
        }

        //Metas
        $this->_formInstance->addGroup(new FormGroup('metas', __('metasrecette.trad', WWP_RECETTE_TEXTDOMAIN), ['class' => ['closed']]));

        $metaFieldsDef = array(
            ['nbPers', NumericField::class], //Nombre de personnes
            ['tpsPrepa', InputField::class], //Temps de préparation
            ['tpsCuisson', InputField::class], //Temps de cuisson
            ['difficulte', InputField::class], //Difficulté
            ['cout', InputField::class], //Cout
            ['published', BooleanField::class], //Publication
            ['astuce', TextAreaField::class], //Astuce
        );

        if (!empty($metaFieldsDef)) {
            foreach ($metaFieldsDef as $def) {
                $displayRules = [
                    'label' => __('meta.' . $def[0] . '.trad', WWP_RECETTE_TEXTDOMAIN),
                    'inputAttributes' => ['name' => 'metas[' . $def[0] . ']']
                ];
                $f = new $def[1]('metas_' . $def[0], (!empty($metaValues[$def[0]]) ? $metaValues[$def[0]] : null), $displayRules);
                $this->_formInstance->addField($f, 'metas');
            }
        }

    }

    private function _generateIngredientsGroup()
    {
        $container = Container::getInstance();
        /** @var EntityManager $entityManager */
        $entityManager = $container->offsetGet('entityManager');

        //Create field group
        $this->_formInstance->addGroup(new FormGroup('ingredients', __('ingredients.trad', WWP_RECETTE_TEXTDOMAIN), ['class' => ['closed']]));

        //Get recipe ingredients
        $thisIngredients = $this->_modelInstance->getIngredients();
        $selectedIngredienIds = $thisIngredients->map(function ($entity) {
            return $entity->getId();
        })->toArray();

        //List all available ingredients;
        $ingredientRepository = $entityManager->getRepository(Ingredient::class);
        $availableIngredients = $ingredientRepository->findBy([], ['slug' => 'ASC']);

        $displayRules = [
            'label' => __('ingredients.add.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => [
                'multiple' => 'multiple',
                'class' => ['ingredientsPicker']
            ]
        ];
        $f = new SelectField('ingredients', $selectedIngredienIds, $displayRules);
        if (!empty($availableIngredients)) {
            $ingredientOptions = array(
                '' => __('ingredients.choose.trad', WWP_RECETTE_TEXTDOMAIN)
            );
            foreach ($availableIngredients as $ingredient) {
                /** @var Ingredient $ingredient */
                $ingredientOptions[$ingredient->getId()] = $ingredient->getSlug();
            }
            $f->setOptions($ingredientOptions);
        }

        $this->_formInstance->addField($f, 'ingredients');

    }

    private function _generateEtapesGroup()
    {
        //Create field group
        $this->_formInstance->addGroup(new FormGroup('etapes', __('etapes.trad', WWP_RECETTE_TEXTDOMAIN)));

        //Get recipe etapes
        $thisEtapes = $this->_modelInstance->getEtapes();

        //One field group per etape
        if (!empty($thisEtapes)) {
            /** @var RecetteEtape $etape */
            foreach ($thisEtapes as $etape) {
                $f = $this->_generateEtapeGroup($etape);
                $this->_formInstance->addField($f, 'etapes');
            }
        }

        //Add etape btn
        $addBtn = new BtnField('add-etape', null, ['label' => 'Ajouter une étape']);
        $this->_formInstance->addField($addBtn, 'etapes');

        //One extra field for new steps
        $f = $this->_generateEtapeGroup(new RecetteEtape());
        $this->_formInstance->addField($f, 'etapes');
    }

    private function _generateEtapeGroup($etape)
    {
        $i = $etape->getId();
        if (empty($i)) {
            $i = '_newstep_';
        }

        /** @var RecetteEtape $etape */
        $displayRules = array();
        if ($i == '_newstep_') {
            $displayRules['inputAttributes']['class'] = ['nouvelle-etape', 'hidden'];
        } else {
            $displayRules['inputAttributes']['class'] = ['etape'];
            $displayRules['after'] = '<button class="button remove-etape">Supprimer</button>';
        }
        $displayRules['wrapAttributes'] = ['no-wrap' => true];
        $f = new FieldGroup('etapes' . $i, null, $displayRules);

        //Id
        $displayRules = [
            'inputAttributes' => [
                'name' => 'etapes[' . $i . '][id]'
            ]
        ];
        $eId = new HiddenField('etape_' . $i . '_id', $etape->getId(), $displayRules);
        $f->addFieldToGroup($eId);

        //Title
        $displayRules = [
            'inputAttributes' => [
                'name' => 'etapes[' . $i . '][title]',
                'placeholder' => __('etape.title.trad', WWP_RECETTE_TEXTDOMAIN),
                'class' => ['etape-title']
            ]
        ];
        $eTitle = new InputField('etape_' . $i . '_title', $etape->getTitle(), $displayRules);
        $f->addFieldToGroup($eTitle);

        //Media
        $displayRules = [
            'label' => __('etape.media.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'etapes[' . $i . '][media]']
        ];
        $eMedia = new MediaField('etape_' . $i . '_media', $etape->getMedia(), $displayRules);
        $f->addFieldToGroup($eMedia);

        //Ingredients
        $availableIngredients = $this->_modelInstance->getIngredients();
        $thisEtapeIngredients = $etape->getIngredients();
        $selectedIngredienIds = $thisEtapeIngredients->map(function ($entity) {
            return $entity->getId();
        })->toArray();
        $displayRules = [
            'label' => __('etape.ingredients.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => [
                'name' => 'etapes[' . $i . '][ingredients]',
                'multiple' => 'multiple',
                'class' => ['ingredientsPicker']
            ]
        ];
        $eIngredients = new SelectField('etape_' . $i . '_ingredients', $selectedIngredienIds, $displayRules);
        $ingredientOptions = array();
        foreach ($availableIngredients as $ingredient) {
            /** @var Ingredient $ingredient */
            $ingredientOptions[$ingredient->getId()] = $ingredient->getSlug();
        }
        $eIngredients->setOptions($ingredientOptions);
        $f->addFieldToGroup($eIngredients);

        //Instructions
        $displayRules = [
            'label' => __('etape.instructions.trad', WWP_RECETTE_TEXTDOMAIN),
            'inputAttributes' => ['name' => 'etapes[' . $i . '][content]']
        ];
        $eInstructions = new TextAreaField('etape_' . $i . '_content', $etape->getContent(), $displayRules);
        $f->addFieldToGroup($eInstructions);

        return $f;
    }

    public function handleRequest(array $data, FormValidatorInterface $formValidator)
    {

        $postedData = $data;

        //Extract Metas
        $rawMetasData = array();
        if (isset($data['metas'])) {
            $rawMetasData = $data['metas'];
            unset($data['metas']);
        }

        //Extract Ingredients
        $rawIngredientsData = array();
        if (isset($data['ingredients'])) {
            $rawIngredientsData = $data['ingredients'];
            unset($data['ingredients']);
        }

        //Extract Etapes
        $rawEtapesData = array();
        if (isset($data['etapes'])) {
            $rawEtapesData = $data['etapes'];
            unset($data['etapes']);
        }

        $errors = parent::handleRequest($data, $formValidator);
        $this->_formInstance->fill($postedData);

        if (!empty($errors)) {
            return $errors;
        }

        $container = Container::getInstance();
        /** @var EntityManager $em */
        $this->_em = $container->offsetGet('entityManager');
        $em = $this->_em;

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;

        //Process Metas
        $metaErrors = $this->_handleMetas($rawMetasData);
        $errors = $errors + $metaErrors;

        //Process Ingredients
        $ingredientErrors = $this->_handleIngredients($rawIngredientsData, $recette);
        $errors = $errors + $ingredientErrors;

        //Process Etapes
        $etapesErrors = $this->_handleEtapes($rawEtapesData);
        $errors = $errors + $etapesErrors;

        $em->flush();

        return $errors;
    }

    private function _handleMetas(array $rawMetasData)
    {
        $errors = array();

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;
        /** @var EntityManager $em */
        $em = $this->_em;

        //Remove old metas
        $currentMetas = $recette->getMetas();
        if (!empty($currentMetas)) {
            foreach ($currentMetas as $m) {
                $recette->removeMeta($m);
                $em->remove($m);
            }
            $em->flush();
        }

        //Add new metas
        if (!empty($rawMetasData)) {
            foreach ($rawMetasData as $key => $val) {
                $meta = new RecetteMeta();
                $meta
                    ->setName($key)
                    ->setVal($val)
                    ->setRecette($recette);
                if ($recette->addMeta($meta)) {
                    $em->persist($meta);
                }
            }
        }
        return $errors;
    }

    private function _handleIngredients(array $rawIngredientsData, AbstractEntity $entity)
    {
        //\WonderWp\trace($rawIngredientsData);
        $errors = array();

        /** @var EntityManager $em */
        $em = $this->_em;
        $thisIngredients = $entity->getIngredients();

        //Remove old ingredients
        //aka those which are in my collection but not the posted ids
        $ingredientsToRemove = $thisIngredients->filter(
            function ($entry) use ($rawIngredientsData) {
                return !in_array($entry->getId(), $rawIngredientsData);
            }
        );
        if (!empty($ingredientsToRemove)) {
            foreach ($ingredientsToRemove as $i) {
                $entity->removeIngredient($i);
            }
            $em->flush();
        }

        //Add new ingredients
        if (!empty($rawIngredientsData)) {
            foreach ($rawIngredientsData as $ingredientId) {
                $ingredient = $em->find(Ingredient::class, $ingredientId);
                $entity->addIngredient($ingredient);
            }
        }

        return $errors;

    }

    private function _handleEtapes($rawEtapesData)
    {

        if (isset($rawEtapesData['_newstep_'])) {
            unset($rawEtapesData['_newstep_']);
        }

        $errors = array();

        /** @var RecetteEntity $recette */
        $recette = $this->_modelInstance;

        /** @var EntityManager $em */
        $em = $this->_em;

        //Remove old etapes
        //aka those which are in my collection but not the posted ids
        $etapesToRemove = $recette->getEtapes()->filter(
            function ($entry) use ($rawEtapesData) {
                return !in_array($entry->getId(), array_keys($rawEtapesData));
            }
        );
        if (!empty($etapesToRemove)) {
            foreach ($etapesToRemove as $e) {
                $recette->removeEtape($e);
            }
            $em->flush();
        }

        //Recreate etapes
        if (!empty($rawEtapesData)) {
            foreach ($rawEtapesData as $val) {
                $id = $val['id'];

                //Extract Ingredients
                $rawIngredientsData = array();
                if (isset($val['ingredients'])) {
                    $rawIngredientsData = $val['ingredients'];
                    unset($val['ingredients']);
                }

                if ($id > 0) {
                    $etape = $em->find(RecetteEtape::class, $id);
                } else {
                    if (empty($val['title'])) {
                        continue;
                    } //pas de donnees postees pour ajouter une nouvelle etape
                    $etape = new RecetteEtape();
                }

                $etape->populate($val)
                    ->setRecette($recette);
                if ($recette->addEtape($etape)) {
                    $em->persist($etape);
                }

                $this->_handleIngredients($rawIngredientsData, $etape);
            }
        }
        $em->flush();


        return $errors;
    }

}